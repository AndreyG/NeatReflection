#include "CodeGenerator.h"

#include "ContextualException.h"

#include <format>
#include <cassert>
#include <cctype>
#include <algorithm>
#include <iostream>

#include "reflifc/Expression.h"
#include "reflifc/TemplateId.h"
#include "reflifc/decl/AliasDeclaration.h"
#include "reflifc/decl/ClassOrStruct.h"
#include "reflifc/decl/Concept.h"
#include "reflifc/decl/Enumeration.h"
#include "reflifc/decl/Function.h"
#include "reflifc/decl/Intrinsic.h"
#include "reflifc/decl/Namespace.h"
#include "reflifc/decl/Parameter.h"
#include "reflifc/decl/TemplateDeclaration.h"
#include "reflifc/decl/UsingDeclaration.h"
#include "reflifc/type/Function.h"
#include "reflifc/type/Pointer.h"
#include "reflifc/type/Placeholder.h"
#include "reflifc/type/Qualified.h"
#include "reflifc/type/Reference.h"

#include "ifc/Expression.h"

#include "magic_enum.hpp"

CodeGenerator::CodeGenerator()
{
	code.reserve(1024);
}

void CodeGenerator::write_cpp_file(reflifc::Module module, std::ostream& out)
{
	auto unit = module.unit();
	if (!unit.is_primary()) // For now
	{
		throw ContextualException("Currently the tool only supports primary module fragments (originating from a .ixx file from MSVC for example).");
	}

	const auto module_name = unit.name();
	
	scan(module.global_namespace());
	
	out << std::format(
R"(// ================================================================================
//                      AUTO GENERATED REFLECTION DATA FILE 
//                    Generated by: NeatReflectionCodeGen.exe
// 
//       Don't modify this file, it will be overwritten when a change is made.
// ================================================================================

#include "Neat/Reflection.h"
#include "Neat/TemplateTypeId.h"

import {0};


namespace Neat
{{
	static void reflect_private_members()
	{{
{1}
	}}

	namespace
	{{
		struct Register{{ Register(){{ Neat::reflect_private_members(); }} }};
		static Register neat_reflection_data_initialiser{{ }};
	}}
}})", module_name, code);

	out.flush();
}

void CodeGenerator::scan(reflifc::Scope scope_desc)
{
	auto declarations = scope_desc.get_declarations();
	for (auto declaration : declarations)
	{
		scan(declaration);
	}
}

void CodeGenerator::scan(reflifc::Declaration decl)
{
	if (decl.is_scope())
		scan(decl.as_scope(), decl);
}

void CodeGenerator::scan(reflifc::ScopeDeclaration scope_decl, reflifc::Declaration decl)
{
	switch (scope_decl.kind())
	{
	case ifc::TypeBasis::Class:
	case ifc::TypeBasis::Struct:
		{
			render(scope_decl.as_class_or_struct(), decl);
		}
		break;
	case ifc::TypeBasis::Union:
		// TODO: Implement at some point
		break;
	case ifc::TypeBasis::Namespace:
		scan(scope_decl.as_namespace().scope());
		break;
	}
}

void CodeGenerator::render(reflifc::ClassOrStruct scope_decl, reflifc::Declaration decl)
{
	if(!is_type_exported(decl))
	{
		return;
	}

	const auto type_name = render_namespace(decl) + scope_decl.name().as_identifier();
	const auto var_name = to_snake_case(type_name) + '_';
	const bool reflect_privates = reflects_private_members(decl);
	const auto [fields, methods] = render_members(type_name, var_name, scope_decl, reflect_privates);
	const auto bases = render_bases(scope_decl);

	code += std::format(R"(add_type({{ "{1}", get_id<{1}>(),
	{{ {2} }},
	{{ {3} }},
	{{ {4} }}
}});
)", var_name, type_name, bases, fields, methods);
}

CodeGenerator::TypeMembers CodeGenerator::render_members(std::string_view type_name, std::string_view type_variable, reflifc::ClassOrStruct scope_decl, bool reflect_private_members)
{
	std::string fields;
	std::string methods;

	auto declarations = scope_decl.members();
	for (auto decl : declarations)
	{
		switch (decl.sort())
		{
		case ifc::DeclSort::Field:
		{
			const auto field = decl.as_field();
			const auto type = render_full_typename(field.type());
			const auto name = field.name();
			const auto access = render_as_neat_access_enum(field.access(), "Access::...");

			if (is_member_publicly_accessible(field, scope_decl.kind(), reflect_private_members))
			{
				fields += std::format(R"(Field::create<{0}, {1}, &{0}::{2}>("{2}", {3}), )", type_name, type, name, access);
			}
			break;
		}
		case ifc::DeclSort::Method:
		{
			const auto method = decl.as_method();
			const auto method_type = method.type();
			const auto return_type = render_full_typename(method_type.return_type());
			auto params = method_type.parameters();
			auto param_types = std::string{ "" };
			param_types.reserve(params.size() * 8);
			for (auto param : params)
			{
				param_types += ", ";
				param_types += render_full_typename(param);
			}
			const auto name = method.name().as_identifier();
			const auto access = render_as_neat_access_enum(method.access());

			if (is_member_publicly_accessible(method, scope_decl.kind(), reflect_private_members))
			{
				methods += std::format(R"(Method::create<&{0}::{3}, {0}, {1}{2}>("{3}", {4}), )", type_name, return_type, param_types, name, access);
			}
			break;
		}
		}
	}
	return { fields, methods };
}

std::string CodeGenerator::render_bases(reflifc::ClassOrStruct scope_decl)
{
	// Otherwise struct
	const bool is_class = (scope_decl.kind() == ifc::TypeBasis::Class);
	const auto default_access = (is_class ? "private" : "public");

	auto bases = scope_decl.bases();

	const auto render_base = [this, default_access] (reflifc::BaseType base_type) -> std::string
	{
		auto access_string = render_as_neat_access_enum(base_type.access, default_access);
		auto type_name = render_full_typename(base_type.type);
		return std::format(R"(BaseClass{{ get_id<{0}>(), {1} }}, )", type_name, access_string);
	};

	std::string rendered;
	rendered.reserve(bases.size() * 16);

	for (auto type : bases)
	{
		rendered += render_base(type);
	}

	return rendered;
}

std::string CodeGenerator::render_full_typename(reflifc::Type type)
{
	switch (type.sort())
	{
	case ifc::TypeSort::Fundamental:
		return render_full_typename(type.as_fundamental());
	case ifc::TypeSort::Designated:
		{
			const auto designated_declaration = type.designation();
			return render_namespace(designated_declaration) + render_refered_declaration(designated_declaration);
		}
	case ifc::TypeSort::Pointer:
		return render_full_typename(type.as_pointer().pointee) + "*";
	case ifc::TypeSort::LvalueReference:
		return render_full_typename(type.as_lvalue_reference().referee) + "&";
	case ifc::TypeSort::RvalueReference:
		return render_full_typename(type.as_rvalue_reference().referee) + "&&";
	case ifc::TypeSort::Qualified:
		return render_full_typename(type.as_qualified().unqualified()) +
			render(type.as_qualified().qualifiers());
	case ifc::TypeSort::Placeholder:
		if (auto elaborated_type = type.as_placeholder().elaboration())
		{
			return render_full_typename(elaborated_type);
		}
		assert(false && "IFC doesn't contain deduced type");
		return "PLACEHOLDER_TYPE";
	case ifc::TypeSort::Function: // U (*)(Args...);
		return render_full_typename(type.as_function());
	case ifc::TypeSort::Syntactic:
		return render_full_typename(type.as_syntactic());

		// Currently unsupported
	case ifc::TypeSort::Expansion: // variadic pack expansion (...)
	case ifc::TypeSort::PointerToMember: // U (T::*);
	case ifc::TypeSort::Method: // U (T::*)(Args...);
	// case ifc::TypeSort::Array: // T t[N]; Not implemented yet in ifc-reader
	// case ifc::TypeSort::Typename: // typename T::dependant_type; Not implementet yet in ifc-reader
	case ifc::TypeSort::Decltype: // Seems to complicated to support
	case ifc::TypeSort::Forall: // Template declaration. Not used yet in MSVC
	case ifc::TypeSort::Unaligned: // __unaligned T; Partition not implemented yet in ifc-reader

		// Not planned to be supported
	case ifc::TypeSort::VendorExtension:
	case ifc::TypeSort::Tor: // Compiler generated constructor
	case ifc::TypeSort::SyntaxTree: // General parse tree representation. Seems to complicated to support

	default:
		//assert(false && "Not supported yet");
		return std::format("<UNSUPPORTED_TYPE {}>", magic_enum::enum_name(type.sort()));
	}
}

std::string CodeGenerator::render_full_typename(reflifc::FunctionType function_type) // U (*)(Args...);
{
	auto return_type = render_full_typename(function_type.return_type());
	std::string parameter_types;
	auto params = function_type.parameters();
	parameter_types.reserve(params.size() * 8);
	bool first = true;
	for (auto param : params)
	{
		if (first)
			first = false;
		else
			parameter_types += ", ";
		parameter_types += render_full_typename(param);
	}
	return return_type + " (" + parameter_types + ")";
}

std::string CodeGenerator::render_full_typename(const ifc::FundamentalType& type)
{
	std::string rendered;
	rendered.reserve(16);

	if (type.sign == ifc::TypeSign::Unsigned)
	{
		rendered += "unsigned ";
	}

	switch (type.precision)
	{
	case ifc::TypePrecision::Default:
		break;
	case ifc::TypePrecision::Short:
		assert(type.basis == ifc::TypeBasis::Int);
		return "short";
	case ifc::TypePrecision::Long:
		rendered += "long ";
		break;
	case ifc::TypePrecision::Bit64:
		assert(type.basis == ifc::TypeBasis::Int);
		return "long long";
	case ifc::TypePrecision::Bit8:
		if (type.basis == ifc::TypeBasis::Char)
		{
			return "char8_t";
		}
	case ifc::TypePrecision::Bit16:
		if (type.basis == ifc::TypeBasis::Char)
		{
			return "char16_t";
		}
	case ifc::TypePrecision::Bit32:
		if (type.basis == ifc::TypeBasis::Char)
		{
			return "char32_t";
		}
	case ifc::TypePrecision::Bit128:
		rendered += std::format("<UNEXPECTED_BITNESS {}>", 
			magic_enum::enum_name(type.precision));
		break;
	}

	switch (type.basis)
	{
	case ifc::TypeBasis::Void:
		rendered += "void";
		break;
	case ifc::TypeBasis::Bool:
		rendered += "bool";
		break;
	case ifc::TypeBasis::Char:
		rendered += "char";
		break;
	case ifc::TypeBasis::Wchar_t:
		rendered += "wchar_t";
		break;
	case ifc::TypeBasis::Int:
		rendered += "int";
		break;
	case ifc::TypeBasis::Float:
		rendered += "float";
		break;
	case ifc::TypeBasis::Double:
		rendered += "double";
		break;
	default:
		rendered += std::format("<UNEXPECTED_FUNCAMENTAL_TYPE {}>", 
			magic_enum::enum_name(type.basis));
		break;
	}

	return rendered;
}


std::string CodeGenerator::render_full_typename(reflifc::TemplateId template_id)
{
	return std::format("{}<{}>",
		render_full_typename(template_id.primary()),
		render_full_typename(template_id.arguments()));
}

std::string CodeGenerator::render_full_typename(reflifc::Expression expr)
{
	switch (expr.sort())
	{
	case ifc::ExprSort::NamedDecl:
		return render_full_typename(expr.referenced_decl());
	case ifc::ExprSort::Type:
		return render_full_typename(expr.as_type());
	case ifc::ExprSort::TemplateId:
		return render_full_typename(expr.as_template_id());
	case ifc::ExprSort::Empty:
		return "";

		// This function is only for rendering a typename, most expression sorts are not used for that so will be ignored:
	default:
		throw ContextualException(std::format("Unexpected expression while rendering typename. ExprSort is: {}",
			magic_enum::enum_name(expr.sort())));
	}
}

std::string CodeGenerator::render_full_typename(reflifc::TupleExpressionView tuple)
{
	std::string rendered;
	rendered.reserve(tuple.size() * 8); // Preallocate a reasonable amount

	bool first = true;
	for (auto expression : tuple)
	{
		if (!first)
		{
			rendered += ", ";
		}

		rendered += render_full_typename(expression);

		first = false;
	}
	return rendered;
}

std::string CodeGenerator::render_full_typename(reflifc::Declaration decl)
{
	return render_namespace(decl) + render_refered_declaration(decl);
}


std::string CodeGenerator::render_refered_declaration(reflifc::Declaration decl)
{
	switch (const auto kind = decl.sort())
	{
	case ifc::DeclSort::Parameter:
	{
		reflifc::Parameter param = decl.as_parameter();
		return param.name();
	}
	break;
	case ifc::DeclSort::Scope:
	{
		reflifc::ScopeDeclaration scope = decl.as_scope();
		return scope.name().as_identifier();
	}
	break;
	case ifc::DeclSort::Template:
	{
		reflifc::TemplateDeclaration template_declaration = decl.as_template();
		return template_declaration.name().as_identifier();
	}
	break;
	case ifc::DeclSort::Function:
	{
		reflifc::Function function = decl.as_function();
		return function.name().as_identifier();
	}
	break;
	//case ifc::DeclSort::Reference:
	//	return std::string{ get_user_type_name(file, file.decl_references()[decl_index]) };
	//	break;
	case ifc::DeclSort::Enumeration:
	{
		auto enumeration = decl.as_enumeration();
		return enumeration.name();
	}
	break;
	default:
		assert(false && "Unsupported declsort");
		return std::format("<UNEXPECTED_DECLSORT {}>", magic_enum::enum_name(kind));
	}
}

std::string CodeGenerator::render_namespace(reflifc::Declaration decl)
{
	switch (const auto sort = decl.sort())
	{
        case ifc::DeclSort::Variable:
			return render_namespace_of_decl(decl.as_variable());
        case ifc::DeclSort::Field:
			return render_namespace_of_decl(decl.as_field());
        case ifc::DeclSort::Scope:
			return render_namespace_of_decl(decl.as_scope());
		case ifc::DeclSort::Intrinsic:
			return render_namespace_of_decl(decl.as_intrinsic());
		case ifc::DeclSort::Enumeration:
			return render_namespace_of_decl(decl.as_enumeration());
        case ifc::DeclSort::Alias:
			return render_namespace_of_decl(decl.as_alias());
        case ifc::DeclSort::Template:
			return render_namespace_of_decl(decl.as_template());
        case ifc::DeclSort::Concept:
			return render_namespace_of_decl(decl.as_concept());
        case ifc::DeclSort::Function:
			return render_namespace_of_decl(decl.as_function());
        case ifc::DeclSort::Method:
			return render_namespace_of_decl(decl.as_method());
        case ifc::DeclSort::Constructor:
			return render_namespace_of_decl(decl.as_constructor());
        case ifc::DeclSort::Destructor:
			return render_namespace_of_decl(decl.as_destructor());
		case ifc::DeclSort::UsingDeclaration:
			return render_namespace_of_decl(decl.as_using());

			// Currently unsupported:
		case ifc::DeclSort::Bitfield:
		case ifc::DeclSort::PartialSpecialization:
		case ifc::DeclSort::Reference: // Reference to an external module's declaration
		case ifc::DeclSort::InheritedConstructor:

			// Unable to get a home_scope for these:
		case ifc::DeclSort::Parameter:
		case ifc::DeclSort::VendorExtension:
		case ifc::DeclSort::Enumerator:
		case ifc::DeclSort::Temploid:
		case ifc::DeclSort::ExplicitSpecialization:
		case ifc::DeclSort::ExplicitInstantiation:
		case ifc::DeclSort::UsingDirective:
		case ifc::DeclSort::Friend:
		case ifc::DeclSort::Expansion:
		case ifc::DeclSort::DeductionGuide:
		case ifc::DeclSort::Barren:
		case ifc::DeclSort::Tuple:
		case ifc::DeclSort::SyntaxTree:
		case ifc::DeclSort::Property:
        case ifc::DeclSort::OutputSegment:
			throw ContextualException( std::format("Cannot get the home_scope for a decl sort of: {}", magic_enum::enum_name(sort)) );
	}
}

std::string CodeGenerator::render_namespace_of_decl(auto decl)
{
	reflifc::Declaration home_scope = decl.home_scope();
	if (!home_scope) {
		return "";
	}

	// Recursive call
	auto rendered_namespace = render_namespace(home_scope) + render_refered_declaration(home_scope);

	if (rendered_namespace.empty()) {
		return "";
	}

	return rendered_namespace + "::";
}

std::string CodeGenerator::render(ifc::Qualifiers qualifiers)
{
	using namespace std::string_view_literals;

	std::string rendered;
	rendered.reserve("const "sv.size() + "volatile "sv.size());
	
	if (ifc::has_qualifier(qualifiers, ifc::Qualifiers::Const))
	{
		rendered += "const ";
	}
	if (ifc::has_qualifier(qualifiers, ifc::Qualifiers::Volatile))
	{
		rendered += "volatile ";
	}
	if (ifc::has_qualifier(qualifiers, ifc::Qualifiers::Restrict))
	{
		// Ignored
	}

	return rendered;
}

std::string CodeGenerator::render_as_neat_access_enum(ifc::Access access, std::string_view value_for_none)
{
	switch (access)
	{
	case ifc::Access::None: return std::string{ value_for_none };
	case ifc::Access::Private: return "Neat::Access::Private";
	case ifc::Access::Protected: return "Neat::Access::Protected";
	case ifc::Access::Public: return "Neat::Access::Public";
	}

	throw ContextualException("Invalid access value.", 
		std::format("Expected 0 to 3 (inclusive). While {0} was given.", static_cast<uint8_t>(access)));
}

std::string CodeGenerator::render_neat_access_enum(Neat::Access access)
{
	switch (access)
	{
	case Neat::Access::Private: return "Neat::Access::Private";
	case Neat::Access::Protected: return "Neat::Access::Protected";
	case Neat::Access::Public: return "Neat::Access::Public";
	default:
		throw ContextualException("Invalid access value.",
			std::format("Expected 0 to 3 (inclusive). While {0} was given.", static_cast<uint8_t>(access)));
	}
}

bool CodeGenerator::reflects_private_members(reflifc::Declaration type_decl)
{
	for (auto expr_index : type_decl.friends())
	{
		switch (expr_index.sort())
		{
		case ifc::ExprSort::NamedDecl:
			{
				auto named_decl = expr_index.referenced_decl();
				if (!named_decl.is_function())
					return false;

				// TODO OPT: Don't require allocations for these comparisons.
				auto friend_name = render_namespace(named_decl) + render_refered_declaration(named_decl);
				auto rendered_type = render_full_typename(named_decl.as_function().type());
				return friend_name == "Neat::reflect_private_members"
					&& rendered_type == "void ()";
			}
		case ifc::ExprSort::TemplateId:
			// Not supported yet

		default:
			std::cout << "Unexpected expr sort in friend declaration! " << magic_enum::enum_name(expr_index.sort()) << "\n";
			break;
		}
	}

	return false;
}

bool CodeGenerator::is_type_exported(reflifc::Type type)
{
	switch (type.sort())
	{
	case ifc::TypeSort::Fundamental:
		return true;
	case ifc::TypeSort::Designated:
		return is_type_exported(type.designation());
	case ifc::TypeSort::Syntactic:
		return is_type_exported(type.as_syntactic());
	case ifc::TypeSort::Method:
		return is_type_exported(type.as_method());
	default:
		throw ContextualException(std::format("Unexpected type while checking if the type was exported. type sort: {}",
			magic_enum::enum_name(type.sort())));
	}
}

bool CodeGenerator::is_type_exported(reflifc::MethodType method)
{
	return is_type_exported(method.return_type()) &&
			std::ranges::all_of(method.parameters(), [this] (reflifc::Type type) { return is_type_exported(type); });
}

bool CodeGenerator::is_type_exported(reflifc::Declaration decl)
{
	ifc::BasicSpecifiers specifiers{};

	switch (decl.sort())
	{
	case ifc::DeclSort::Scope:
		specifiers = decl.as_scope().specifiers();
		break;
	case ifc::DeclSort::Enumeration:
		specifiers = decl.as_enumeration().specifiers();
		break;
	case ifc::DeclSort::Template:
		specifiers = decl.as_template().specifiers();
		break;
	default:
		throw ContextualException(std::format("Unexpected declaration while checking if the type decl was exported. type decl sort: {}",
			magic_enum::enum_name(decl.sort())));
	}

	using namespace magic_enum::bitwise_operators;
	return (magic_enum::enum_underlying(specifiers & ifc::BasicSpecifiers::NonExported) == 0);
}

bool CodeGenerator::is_type_exported(reflifc::Expression expr)
{
	switch (expr.sort())
	{
	case ifc::ExprSort::NamedDecl:
		return is_type_exported(expr.referenced_decl());
	case ifc::ExprSort::Type:
		return is_type_exported(expr.as_type());
	case ifc::ExprSort::TemplateId:
		return is_type_exported(expr.as_template_id());
	case ifc::ExprSort::Empty:
		return false;

		// Not supported currently, will need more investigation.
	case ifc::ExprSort::Lambda:
	case ifc::ExprSort::UnresolvedId:
	case ifc::ExprSort::SimpleIdentifier:

	case ifc::ExprSort::UnqualifiedId:
	case ifc::ExprSort::QualifiedName:
	case ifc::ExprSort::Path:

		// The rest is not supported, these expressions are for internals similar to a syntax tree.
	default:
		throw ContextualException(std::format("Unexpected expression while checking if the type can be exported. ExprSort is: {}",
			magic_enum::enum_name(expr.sort())));
	}
}

bool CodeGenerator::is_type_exported(reflifc::TemplateId template_id)
{
	return is_type_exported(template_id.primary()) &&
		std::ranges::all_of(template_id.arguments(), [this](reflifc::Expression arg)
		{
			return is_type_exported(arg);
		});
}

std::optional<Neat::Access> convert(ifc::Access ifc_access)
{
	switch (ifc_access)
	{
	case ifc::Access::None: return std::nullopt;
	case ifc::Access::Private: return Neat::Access::Private;
	case ifc::Access::Protected: return Neat::Access::Protected;
	case ifc::Access::Public: return Neat::Access::Public;
	default:
		throw ContextualException(std::format("Invalid value for ifc::Access. {} to {} (inclusive) was expected, but {} was given",
			magic_enum::enum_underlying(ifc::Access::None), magic_enum::enum_underlying(ifc::Access::Public), magic_enum::enum_underlying(ifc_access)));
	}
}

std::string replace_all_copy(std::string str, std::string_view target, std::string_view replacement)
{
	size_t start_pos = 0;
	while ((start_pos = str.find(target, start_pos)) != std::string::npos) {
		str.replace(start_pos, target.length(), replacement);
		start_pos += replacement.length(); // Handles case where 'to' is a substring of 'from'
	}
	return str;
}

std::string to_snake_case(std::string_view type_name)
{
	std::string snake_case;
	snake_case.reserve(type_name.size() + 10);

	bool previous_uppercase = true;
	for (auto c : type_name)
	{
		if (!previous_uppercase && std::isupper(c))
		{
			snake_case.push_back('_');
		}

		if (std::isalnum(c))
		{
			snake_case.push_back(std::tolower(c));
		}
		else 
		{
			snake_case.push_back('_'); // Fallback
		}

		previous_uppercase = std::isupper(c);
	}

	return snake_case;
}